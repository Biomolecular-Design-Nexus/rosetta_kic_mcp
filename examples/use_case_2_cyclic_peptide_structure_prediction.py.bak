#!/usr/bin/env python3
"""
Use Case 2: Cyclic Peptide Structure Prediction

This script demonstrates how to use Rosetta's simple_cycpep_predict application
for ab initio structure prediction of cyclic peptides. It uses MPI-based
sampling with GenKIC closure and various filters.

Based on: simple_cycpep_predict scientific test

Usage:
    python use_case_2_cyclic_peptide_structure_prediction.py --sequence <sequence> [options]

Requirements:
    - Rosetta simple_cycpep_predict executable
    - MPI (for parallel execution)
"""

import argparse
import os
import sys
import time
import subprocess
from pathlib import Path

# Default Rosetta parameters for cyclic peptide prediction
DEFAULT_PARAMS = {
    'ex1': True,
    'ex2': True,
    'MPI_pnear_lambda': 1.25,
    'MPI_pnear_kbt': 0.62,
    'nstruct': 1000,  # Reduced from 1000000000 for practical use
    'cyclic_peptide_MPI_batchsize_by_level': 1,
    'cyclic_peptide_MPI_auto_2level_distribution': True,
    'multithreading_total_threads': 1,
    'threads_per_worker': 1,
    'cyclic_peptide_compute_rmsd_to_lowest': True,
    'cyclic_peptide_compute_ensemble_sasa_metrics': True,
    'cyclic_peptide_sample_cis_pro_frequency': 0.3,
    'cyclic_peptide_MPI_output_fraction': 0.001,
    'score_symmetric_gly_tables': True,
    'cyclic_peptide_genkic_closure_attempts': 250,
    'cyclic_peptide_genkic_min_solution_count': 1,
    'cyclic_peptide_use_rama_filter': True,
    'cyclic_peptide_rama_cutoff': 3.0,
    'cyclic_peptide_min_genkic_hbonds': 2,
    'cyclic_peptide_min_final_hbonds': 2,
    'mute': 'all',
    'no_color': True,
}

def find_rosetta_executable(executable_name='simple_cycpep_predict'):
    """
    Find the Rosetta executable in common locations.

    Args:
        executable_name: Name of the executable to find

    Returns:
        Path to executable or None if not found
    """
    # Common Rosetta installation paths
    possible_paths = [
        f'./rosetta/source/bin/{executable_name}',
        f'../rosetta/source/bin/{executable_name}',
        f'~/rosetta/source/bin/{executable_name}',
        f'/usr/local/rosetta/source/bin/{executable_name}',
        f'/opt/rosetta/source/bin/{executable_name}',
    ]

    # Check if executable is in PATH
    try:
        result = subprocess.run(['which', executable_name],
                              capture_output=True, text=True)
        if result.returncode == 0:
            return result.stdout.strip()
    except:
        pass

    # Check common paths
    for path in possible_paths:
        expanded_path = os.path.expanduser(path)
        if os.path.isfile(expanded_path):
            return expanded_path

    # Look for executables with different extensions
    extensions = ['.default.linuxgccrelease', '.mpi.linuxgccrelease',
                 '.static.linuxgccrelease', '.linuxgccrelease']

    for path in possible_paths:
        for ext in extensions:
            full_path = os.path.expanduser(path + ext)
            if os.path.isfile(full_path):
                return full_path

    return None

def create_sequence_file(sequence, output_path):
    """
    Create a sequence file for Rosetta input.

    Args:
        sequence: Amino acid sequence (single letter codes)
        output_path: Path to write sequence file
    """
    with open(output_path, 'w') as f:
        f.write(f"{sequence}\n")

def build_command_line(params, database_path, sequence_file, output_dir,
                      native_pdb=None, run_time=900):
    """
    Build the command line for simple_cycpep_predict.

    Args:
        params: Dictionary of parameters
        database_path: Path to Rosetta database
        sequence_file: Path to sequence file
        output_dir: Output directory
        native_pdb: Optional native structure for RMSD calculation
        run_time: Maximum runtime in seconds

    Returns:
        List of command line arguments
    """
    cmd = ['-database', database_path]

    if native_pdb:
        cmd.extend(['-in:file:native', native_pdb])

    # Add boolean flags
    if params.get('ex1'):
        cmd.append('-ex1')
    if params.get('ex2'):
        cmd.append('-ex2')

    # Add numerical parameters
    for key, value in params.items():
        if key in ['ex1', 'ex2']:
            continue  # Already handled

        rosetta_key = key.replace('_', ':')
        if isinstance(value, bool):
            if value:
                cmd.append(f'-{rosetta_key}')
        else:
            cmd.extend([f'-{rosetta_key}', str(value)])

    # Add file paths
    cmd.extend(['-cyclic_peptide:sequence_file', sequence_file])
    cmd.extend(['-out:file:silent', os.path.join(output_dir, 'out.silent')])
    cmd.extend(['-cyclic_peptide:MPI_stop_after_time', str(run_time)])

    # Unmute specific protocols
    cmd.extend(['-unmute',
               'protocols.cyclic_peptide_predict.SimpleCycpepPredictApplication_MPI_summary',
               'protocols.cyclic_peptide_predict.SimpleCycpepPredictApplication_MPI'])

    return cmd

def predict_cyclic_peptide_structure(sequence, output_dir, database_path=None,
                                   native_pdb=None, run_time=900, nstruct=1000,
                                   use_mpi=False, num_processors=1):
    """
    Main function to predict cyclic peptide structure.

    Args:
        sequence: Amino acid sequence (single letter codes)
        output_dir: Output directory for results
        database_path: Path to Rosetta database
        native_pdb: Optional native structure for comparison
        run_time: Maximum runtime in seconds
        nstruct: Number of structures to generate
        use_mpi: Whether to use MPI for parallel execution
        num_processors: Number of MPI processors to use
    """
    # Create output directory
    os.makedirs(output_dir, exist_ok=True)

    # Find Rosetta executable
    if use_mpi:
        executable = find_rosetta_executable('simple_cycpep_predict.mpi')
        if not executable:
            executable = find_rosetta_executable('simple_cycpep_predict')
            print("Warning: MPI executable not found, using serial version")
    else:
        executable = find_rosetta_executable('simple_cycpep_predict')

    if not executable:
        print("Error: Could not find simple_cycpep_predict executable")
        print("Please ensure Rosetta is installed and compiled")
        return False

    print(f"Using executable: {executable}")

    # Find database if not provided
    if database_path is None:
        # Try to infer from executable path
        exe_dir = os.path.dirname(os.path.dirname(executable))
        potential_db = os.path.join(exe_dir, 'database')
        if os.path.isdir(potential_db):
            database_path = potential_db
        else:
            print("Error: Could not find Rosetta database")
            print("Please specify --database path")
            return False

    # Create sequence file
    sequence_file = os.path.join(output_dir, 'sequence.txt')
    create_sequence_file(sequence, sequence_file)

    # Set up parameters
    params = DEFAULT_PARAMS.copy()
    params['nstruct'] = nstruct

    # Build command line
    cmd_args = build_command_line(
        params, database_path, sequence_file, output_dir,
        native_pdb, run_time
    )

    # Build full command
    if use_mpi and num_processors > 1:
        cmd = ['mpirun', '-np', str(num_processors), executable] + cmd_args
    else:
        cmd = [executable] + cmd_args

    print(f"Running command:")
    print(' '.join(cmd))
    print(f"Working directory: {output_dir}")
    print(f"Sequence: {sequence}")
    print(f"Expected runtime: {run_time} seconds")
    print()

    # Run the prediction
    start_time = time.time()
    try:
        result = subprocess.run(
            cmd,
            cwd=output_dir,
            capture_output=True,
            text=True,
            timeout=run_time + 300  # Add buffer time
        )

        # Write output logs
        with open(os.path.join(output_dir, 'stdout.log'), 'w') as f:
            f.write(result.stdout)

        with open(os.path.join(output_dir, 'stderr.log'), 'w') as f:
            f.write(result.stderr)

        if result.returncode == 0:
            print("Structure prediction completed successfully!")
            elapsed = time.time() - start_time
            print(f"Runtime: {elapsed:.1f} seconds")

            # Check output files
            silent_file = os.path.join(output_dir, 'out.silent')
            if os.path.exists(silent_file):
                file_size = os.path.getsize(silent_file)
                print(f"Output silent file: {silent_file} ({file_size} bytes)")

            return True
        else:
            print(f"Error: Process returned exit code {result.returncode}")
            print("Check stdout.log and stderr.log for details")
            return False

    except subprocess.TimeoutExpired:
        print(f"Warning: Process timed out after {run_time + 300} seconds")
        return False
    except Exception as e:
        print(f"Error running prediction: {e}")
        return False

def main():
    parser = argparse.ArgumentParser(
        description='Predict cyclic peptide structures using Rosetta',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Basic structure prediction
    python use_case_2_cyclic_peptide_structure_prediction.py --sequence "GRGDSP" --output_dir results

    # With native structure for comparison
    python use_case_2_cyclic_peptide_structure_prediction.py --sequence "GRGDSP" --output_dir results --native examples/data/structures/native.pdb

    # High-throughput with MPI
    python use_case_2_cyclic_peptide_structure_prediction.py --sequence "GRGDSPK" --output_dir results --nstruct 10000 --use_mpi --num_processors 8

    # Extended runtime for difficult sequences
    python use_case_2_cyclic_peptide_structure_prediction.py --sequence "CRGDSPKC" --output_dir results --runtime 3600
        """
    )

    parser.add_argument('-s', '--sequence', required=True,
                       help='Amino acid sequence (single letter codes)')
    parser.add_argument('-o', '--output_dir', required=True,
                       help='Output directory for results')
    parser.add_argument('--database',
                       help='Path to Rosetta database (auto-detected if not specified)')
    parser.add_argument('--native',
                       help='Native PDB structure for RMSD calculation')
    parser.add_argument('--runtime', type=int, default=900,
                       help='Maximum runtime in seconds (default: 900)')
    parser.add_argument('--nstruct', type=int, default=1000,
                       help='Number of structures to generate (default: 1000)')
    parser.add_argument('--use_mpi', action='store_true',
                       help='Use MPI for parallel execution')
    parser.add_argument('--num_processors', type=int, default=1,
                       help='Number of MPI processors (default: 1)')

    args = parser.parse_args()

    # Validate sequence
    valid_aa = set('ACDEFGHIKLMNPQRSTVWY')
    if not all(aa in valid_aa for aa in args.sequence.upper()):
        print("Error: Invalid amino acid sequence")
        print("Use single letter codes: A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y")
        return 1

    if len(args.sequence) < 3:
        print("Error: Sequence must be at least 3 residues long")
        return 1

    if len(args.sequence) > 20:
        print("Warning: Long sequences may require extended runtime")

    print(f"Starting cyclic peptide structure prediction")
    print(f"Sequence: {args.sequence} ({len(args.sequence)} residues)")
    print(f"Output directory: {args.output_dir}")
    print(f"Number of structures: {args.nstruct}")
    if args.use_mpi:
        print(f"Using MPI with {args.num_processors} processors")

    try:
        success = predict_cyclic_peptide_structure(
            sequence=args.sequence.upper(),
            output_dir=args.output_dir,
            database_path=args.database,
            native_pdb=args.native,
            run_time=args.runtime,
            nstruct=args.nstruct,
            use_mpi=args.use_mpi,
            num_processors=args.num_processors
        )

        if success:
            print("\nPrediction completed successfully!")
            print(f"Results saved to: {args.output_dir}")
            return 0
        else:
            print("\nPrediction failed!")
            return 1

    except KeyboardInterrupt:
        print("\nInterrupted by user")
        return 1
    except Exception as e:
        print(f"Unexpected error: {e}")
        return 1

if __name__ == '__main__':
    sys.exit(main())