#!/usr/bin/env python3
"""
Use Case 3: KIC (Kinematic Closure) Loop Modeling

This script demonstrates how to use Rosetta's Kinematic Closure (KIC) algorithm
for loop modeling and remodeling. This is useful for modeling flexible regions
in peptides and proteins.

Based on: loops_kic.py from PyRosetta demos

Usage:
    python use_case_3_kic_loop_modeling.py --input <pdb_file> --loop_start <start> --loop_end <end> [options]

Requirements:
    - PyRosetta (from the Rosetta repository)
    - Input PDB file with protein/peptide structure
"""

import argparse
import math
import os
import sys
from random import randrange

try:
    from rosetta import *
    from rosetta.core.scoring import ScoreFunction
    PYROSETTA_AVAILABLE = True
except ImportError:
    PYROSETTA_AVAILABLE = False
    print("Warning: PyRosetta not available. This is a demonstration script.")
    print("Install PyRosetta to run actual KIC loop modeling.")

# Constants
MAX_KIC_BUILD_ATTEMPTS = 10000

def setup_rosetta():
    """Initialize Rosetta with appropriate settings."""
    if not PYROSETTA_AVAILABLE:
        return None, None

    args = [
        "app",
        "-database", "minirosetta_database",  # Will need to be adjusted for actual database path
        "-loops:fast"  # Reduce cycles for testing
    ]

    try:
        init(*args)
        scorefxn_low = create_score_function('cen_std')
        scorefxn_high = create_score_function('standard', 'score12')
        return scorefxn_low, scorefxn_high
    except Exception as e:
        print(f"Warning: Could not initialize Rosetta with standard database: {e}")
        print("Trying with minimal initialization...")
        try:
            init()
            scorefxn_low = create_score_function('cen_std')
            scorefxn_high = create_score_function('standard')
            return scorefxn_low, scorefxn_high
        except Exception as e2:
            print(f"Error: Could not initialize Rosetta: {e2}")
            return None, None

def model_loop_kic(pose, loop_start, loop_end, loop_cut=None,
                   outer_cycles=10, inner_cycles=30,
                   init_temp=2.0, final_temp=1.0,
                   output_prefix="kic_model",
                   display_pymol=False):
    """
    Model a loop using Kinematic Closure (KIC).

    Args:
        pose: Rosetta Pose object
        loop_start: Starting residue number of the loop
        loop_end: Ending residue number of the loop
        loop_cut: Cut point for the loop (auto-calculated if None)
        outer_cycles: Number of outer Monte Carlo cycles
        inner_cycles: Number of inner Monte Carlo cycles
        init_temp: Initial temperature for Monte Carlo
        final_temp: Final temperature for Monte Carlo
        output_prefix: Prefix for output files
        display_pymol: Whether to display in PyMOL (requires PyMOL server)

    Returns:
        Success status and final pose
    """
    if not PYROSETTA_AVAILABLE:
        print("PyRosetta not available - cannot perform actual loop modeling")
        return False, None

    # Initialize score functions
    scorefxn_low, scorefxn_high = setup_rosetta()
    if scorefxn_low is None:
        return False, None

    # Set up PyMOL display if requested
    pymol = None
    if display_pymol:
        try:
            pymol = rosetta.PyMOLMover()
        except:
            print("Warning: Could not set up PyMOL display")

    # Set loop cut point if not provided
    if loop_cut is None:
        loop_cut = (loop_start + loop_end) // 2

    # Validate loop parameters
    if loop_end <= loop_start:
        print("Error: Loop end must be greater than loop start")
        return False, None

    if loop_cut <= loop_start or loop_cut >= loop_end:
        print("Error: Loop cut must be between loop start and end")
        return False, None

    print(f"Modeling loop from residue {loop_start} to {loop_end} with cut at {loop_cut}")

    # Create loop object
    my_loop = Loop(loop_start, loop_end, loop_cut)
    my_loops = Loops()
    my_loops.add_loop(my_loop)
    print(f"Loop definition: {my_loop}")

    # Set fold tree for loop modeling
    set_single_loop_fold_tree(pose, my_loop)
    print(f"Fold tree: {pose.fold_tree()}")

    # Save starting pose
    starting_pose = Pose()
    starting_pose.assign(pose)

    # Set up movers
    kic_mover = KinematicMover()

    # Centroid/fullatom conversion movers
    to_centroid = protocols.simple_moves.SwitchResidueTypeSetMover('centroid')
    to_fullatom = protocols.simple_moves.SwitchResidueTypeSetMover('fa_standard')
    recover_sidechains = protocols.simple_moves.ReturnSidechainMover(starting_pose)

    # Set up sidechain packer
    try:
        task_pack = TaskFactory.create_packer_task(starting_pose)
        task_pack.restrict_to_repacking()
        task_pack.or_include_current(True)
        pack = protocols.minimization_packing.PackRotamersMover(scorefxn_high, task_pack)
    except:
        print("Warning: Could not set up packer, using default")
        pack = None

    # Convert to centroid mode
    print("Converting to centroid mode...")
    to_centroid.apply(pose)

    # Set up centroid stage MoveMap
    movemap = MoveMap()
    movemap.set_bb_true_range(loop_start, loop_end)
    movemap.set_chi(True)

    # Set up minimizer
    tol = 0.001
    min_type = "linmin"
    linmin_mover = protocols.minimization_packing.MinMover(
        movemap, scorefxn_low, min_type, tol, True
    )

    # Save starting centroid pose
    starting_pose_centroid = Pose()
    starting_pose_centroid.assign(pose)

    # Build initial loop conformation with KIC
    print("Building random loop conformation with KIC...")
    success = False
    kic_mover.set_idealize_loop_first(True)
    kic_mover.set_pivots(loop_start, loop_cut, loop_end)

    if pymol:
        pymol.apply(pose)

    for i in range(MAX_KIC_BUILD_ATTEMPTS):
        print(f"  Attempt {i+1}...", end=' ')
        kic_mover.apply(pose)

        if pymol:
            pymol.apply(pose)

        if kic_mover.last_move_succeeded():
            success = True
            kic_mover.set_idealize_loop_first(False)
            print("SUCCESS")
            break
        else:
            print("failed")

    if not success:
        print(f"Could not complete initial KIC loop building in {MAX_KIC_BUILD_ATTEMPTS} attempts")
        return False, None

    # Initial minimization
    scorefxn_low(pose)
    linmin_mover.apply(pose)

    # Monte Carlo loop remodeling in centroid stage
    print(f"Centroid stage loop KIC remodeling...")
    print(f"Outer cycles: {outer_cycles}, Inner cycles: {inner_cycles}")

    gamma = math.pow((final_temp / init_temp), (1.0 / (outer_cycles * inner_cycles)))
    kT = init_temp
    mc = MonteCarlo(pose, scorefxn_low, kT)

    for i in range(1, outer_cycles + 1):
        mc.recover_low(pose)
        scorefxn_low(pose)

        for j in range(1, inner_cycles + 1):
            kT = kT * gamma
            mc.set_temperature(kT)

            # Randomly select KIC pivot points
            kic_start = randrange(loop_start, loop_end - 1)
            kic_end = randrange(kic_start + 2, loop_end + 1)
            middle_offset = (kic_end - kic_start) // 2
            kic_middle = kic_start + middle_offset

            kic_mover.set_pivots(kic_start, kic_middle, kic_end)
            kic_mover.set_temperature(kT)
            kic_mover.apply(pose)
            linmin_mover.apply(pose)
            mc.boltzmann(pose)

            if pymol:
                pymol.apply(pose)

            # Calculate RMSD
            try:
                rms = loop_rmsd(pose, starting_pose, my_loops)
                print(f"Cycle {i}.{j}: Loop RMSD = {rms:.3f}, Temp = {kT:.3f}")
            except:
                print(f"Cycle {i}.{j}: Temp = {kT:.3f}")

    mc.recover_low(pose)

    # Convert to full-atom and refine
    print("Converting to full-atom and refining...")
    to_fullatom.apply(pose)
    recover_sidechains.apply(pose)

    if pack:
        pack.apply(pose)

    # High-resolution refinement
    try:
        loop_refine = LoopMover_Refine_KIC(my_loops)
        loop_refine.apply(pose)
        if pymol:
            pymol.apply(pose)
    except Exception as e:
        print(f"Warning: Could not perform high-resolution refinement: {e}")

    # Calculate final RMSD and energy
    final_score = scorefxn_high(pose)
    print(f"Final high-resolution score: {final_score:.2f}")

    try:
        final_rmsd = loop_rmsd(pose, starting_pose, my_loops)
        print(f"Final loop RMSD to starting structure: {final_rmsd:.3f}")
    except:
        print("Could not calculate final RMSD")

    # Output final structure
    output_file = f"{output_prefix}_final.pdb"
    pose.dump_pdb(output_file)
    print(f"Final structure saved to: {output_file}")

    return True, pose

def main():
    parser = argparse.ArgumentParser(
        description='Model loops using Kinematic Closure (KIC)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Basic loop modeling
    python use_case_3_kic_loop_modeling.py --input examples/data/structures/protein.pdb --loop_start 10 --loop_end 20

    # With custom cut point and parameters
    python use_case_3_kic_loop_modeling.py --input protein.pdb --loop_start 145 --loop_end 155 --loop_cut 150 --outer_cycles 15

    # Extended sampling
    python use_case_3_kic_loop_modeling.py --input protein.pdb --loop_start 10 --loop_end 25 --outer_cycles 20 --inner_cycles 50

    # With PyMOL display
    python use_case_3_kic_loop_modeling.py --input protein.pdb --loop_start 10 --loop_end 20 --display_pymol
        """
    )

    parser.add_argument('-i', '--input', required=True,
                       help='Input PDB file')
    parser.add_argument('--loop_start', type=int, required=True,
                       help='Starting residue number of the loop (1-indexed)')
    parser.add_argument('--loop_end', type=int, required=True,
                       help='Ending residue number of the loop (1-indexed)')
    parser.add_argument('--loop_cut', type=int,
                       help='Cut point for the loop (auto-calculated if not specified)')
    parser.add_argument('--outer_cycles', type=int, default=10,
                       help='Number of outer Monte Carlo cycles (default: 10)')
    parser.add_argument('--inner_cycles', type=int, default=30,
                       help='Number of inner Monte Carlo cycles (default: 30)')
    parser.add_argument('--init_temp', type=float, default=2.0,
                       help='Initial temperature for Monte Carlo (default: 2.0)')
    parser.add_argument('--final_temp', type=float, default=1.0,
                       help='Final temperature for Monte Carlo (default: 1.0)')
    parser.add_argument('-o', '--output_prefix', default='kic_model',
                       help='Prefix for output files (default: kic_model)')
    parser.add_argument('--display_pymol', action='store_true',
                       help='Display modeling process in PyMOL (requires PyMOL server)')
    parser.add_argument('--fast', action='store_true',
                       help='Use fast mode (reduced cycles for testing)')

    args = parser.parse_args()

    if not os.path.exists(args.input):
        print(f"Error: Input file {args.input} not found")
        return 1

    if args.loop_end <= args.loop_start:
        print("Error: Loop end must be greater than loop start")
        return 1

    if args.loop_cut and (args.loop_cut <= args.loop_start or args.loop_cut >= args.loop_end):
        print("Error: Loop cut must be between loop start and loop end")
        return 1

    # Adjust parameters for fast mode
    if args.fast:
        outer_cycles = max(3, args.outer_cycles // 3)
        inner_cycles = max(10, args.inner_cycles // 3)
        print(f"Fast mode: Using {outer_cycles} outer cycles and {inner_cycles} inner cycles")
    else:
        outer_cycles = args.outer_cycles
        inner_cycles = args.inner_cycles

    print(f"Starting KIC loop modeling")
    print(f"Input: {args.input}")
    print(f"Loop region: {args.loop_start}-{args.loop_end}")
    if args.loop_cut:
        print(f"Cut point: {args.loop_cut}")
    print(f"Monte Carlo cycles: {outer_cycles} outer, {inner_cycles} inner")
    print(f"Temperature range: {args.init_temp} -> {args.final_temp}")

    if not PYROSETTA_AVAILABLE:
        print("\nThis is a demonstration script - PyRosetta is required for actual execution")
        return 0

    try:
        # Load pose
        pose = Pose()
        pose_from_file(pose, args.input)
        print(f"Loaded structure with {pose.size()} residues")

        # Validate loop region
        if args.loop_start < 1 or args.loop_end > pose.size():
            print(f"Error: Loop region {args.loop_start}-{args.loop_end} is outside structure (1-{pose.size()})")
            return 1

        # Run KIC modeling
        success, final_pose = model_loop_kic(
            pose=pose,
            loop_start=args.loop_start,
            loop_end=args.loop_end,
            loop_cut=args.loop_cut,
            outer_cycles=outer_cycles,
            inner_cycles=inner_cycles,
            init_temp=args.init_temp,
            final_temp=args.final_temp,
            output_prefix=args.output_prefix,
            display_pymol=args.display_pymol
        )

        if success:
            print("KIC loop modeling completed successfully!")
            return 0
        else:
            print("KIC loop modeling failed!")
            return 1

    except KeyboardInterrupt:
        print("\nInterrupted by user")
        return 1
    except Exception as e:
        print(f"Error during loop modeling: {e}")
        import traceback
        traceback.print_exc()
        return 1

if __name__ == '__main__':
    sys.exit(main())